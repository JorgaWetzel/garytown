function Set-PendingUpdate {
    # Set the registry key to indicate a pending update
    $RebootRequiredPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
    if (-not (Test-Path $RebootRequiredPath)) {New-Item -Path $registryPath -Force | Out-Null}
    # Create a value to indicate a pending update
    New-ItemProperty -Path $RebootRequiredPath -Name "UpdatePending" -Value 1 -PropertyType DWord -Force
    
    
    # Set the orchestrator key to 15
    $OrchestratorPath = "HKLM:\SOFTWARE\Microsoft\WindowsUpdate\Orchestrator"
    New-ItemProperty -Path $OrchestratorPath -Name "ShutdownFlyoutOptions" -Value 10 -PropertyType DWord -Force
    New-ItemProperty -Path $OrchestratorPath -Name "EnhancedShutdownEnabled" -Value 1 -PropertyType DWord -Force

    $RebootDowntimePath = "HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\RebootDowntime"
    New-ItemProperty -Path $RebootDowntimePath -Name "DowntimeEstimateHigh" -Value 1 -PropertyType DWord -Force
    New-ItemProperty -Path $RebootDowntimePath -Name "DowntimeEstimateLow" -Value 1 -PropertyType DWord -Force
    
}
Function Invoke-SystemTrayIcon {

    # Thanks Thomas Levesque at http://bit.ly/1KmLgyN and darkfall http://git.io/vZxRK 
    $code = '
        using System;
        using System.Drawing;
        using System.Runtime.InteropServices;
        using System.IO;
        
        namespace System {
            public class IconExtractor {
                public static Icon Extract(string file, int number, bool largeIcon) {
                    IntPtr large;
                    IntPtr small;
                    ExtractIconEx(file, number, out large, out small, 1);
                    try  { return Icon.FromHandle(largeIcon ? large : small); }
                    catch  { return null; }
                }
                [DllImport("Shell32.dll", EntryPoint = "ExtractIconExW", CharSet = CharSet.Unicode, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
                private static extern int ExtractIconEx(string sFile, int iIndex, out IntPtr piLargeVersion, out IntPtr piSmallVersion, int amountIcons);
            }
        }
        
        public class PngIconConverter
        {
            public static bool Convert(System.IO.Stream input_stream, System.IO.Stream output_stream, int size, bool keep_aspect_ratio = false)
            {
                System.Drawing.Bitmap input_bit = (System.Drawing.Bitmap)System.Drawing.Bitmap.FromStream(input_stream);
                if (input_bit != null)
                {
                    int width, height;
                    if (keep_aspect_ratio)
                    {
                        width = size;
                        height = input_bit.Height / input_bit.Width * size;
                    }
                    else
                    {
                        width = height = size;
                    }
                    System.Drawing.Bitmap new_bit = new System.Drawing.Bitmap(input_bit, new System.Drawing.Size(width, height));
                    if (new_bit != null)
                    {
                        System.IO.MemoryStream mem_data = new System.IO.MemoryStream();
                        new_bit.Save(mem_data, System.Drawing.Imaging.ImageFormat.Png);
    
                        System.IO.BinaryWriter icon_writer = new System.IO.BinaryWriter(output_stream);
                        if (output_stream != null && icon_writer != null)
                        {
                            icon_writer.Write((byte)0);
                            icon_writer.Write((byte)0);
                            icon_writer.Write((short)1);
                            icon_writer.Write((short)1);
                            icon_writer.Write((byte)width);
                            icon_writer.Write((byte)height);
                            icon_writer.Write((byte)0);
                            icon_writer.Write((byte)0);
                            icon_writer.Write((short)0);
                            icon_writer.Write((short)32);
                            icon_writer.Write((int)mem_data.Length);
                            icon_writer.Write((int)(6 + 16));
                            icon_writer.Write(mem_data.ToArray());
                            icon_writer.Flush();
                            return true;
                        }
                    }
                    return false;
                }
                return false;
            }
    
            public static bool Convert(string input_image, string output_icon, int size, bool keep_aspect_ratio = false)
            {
                System.IO.FileStream input_stream = new System.IO.FileStream(input_image, System.IO.FileMode.Open);
                System.IO.FileStream output_stream = new System.IO.FileStream(output_icon, System.IO.FileMode.OpenOrCreate);
    
                bool result = Convert(input_stream, output_stream, size, keep_aspect_ratio);
    
                input_stream.Close();
                output_stream.Close();
    
                return result;
            }
        }
    '
        
    Add-Type -TypeDefinition $code -ReferencedAssemblies System.Drawing, System.IO -ErrorAction SilentlyContinue
    
    
    if (!(test-path "$env:TEMP\MahApps.Metro.2.4.10\lib\net47\MahApps.Metro.dll")){
        $MahAppURL = 'https://github.com/MahApps/MahApps.Metro/releases/download/2.4.10/MahApps.Metro.2.4.10.nupkg'
        if ((Test-NetConnection -ComputerName github.com -CommonTCPPort HTTP -ErrorAction SilentlyContinue).TcpTestSucceeded -eq $true){
            #Start-BitsTransfer -Source $MahAppURL -Destination "$env:TEMP\MahApps.Metro.2.4.10.nupkg" -DisplayName "Downloading MahApps.Metro 2.4.10"
            invoke-webrequest -uri $MahAppURL -outfile "$env:TEMP\MahApps.Metro.2.4.10.zip"
            Expand-Archive -Path "$env:TEMP\MahApps.Metro.2.4.10.zip" -DestinationPath "$env:TEMP\MahApps.Metro.2.4.10"
            #Copy-Item -Path "$env:TEMP\MahApps.Metro.2.4.10\lib\net47\MahApps.Metro.dll" -Destination "$env:TEMP\MahApps.Metro.dll"
        }
    }
     
    # Add assemblies for WPF and Mahapps
    [System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms') | out-null
    [System.Reflection.Assembly]::LoadWithPartialName('presentationframework') | out-null
    [System.Reflection.Assembly]::LoadWithPartialName('System.Drawing') | out-null
    [System.Reflection.Assembly]::LoadWithPartialName('WindowsFormsIntegration') | out-null
    [System.Reflection.Assembly]::LoadFrom("$env:TEMP\MahApps.Metro.2.4.10\lib\net47\MahApps.Metro.dll") | out-null
     
    # Choose an icon to display in the systray
    #$icon = [System.Drawing.Icon]::ExtractAssociatedIcon("C:\Windows\System32\ServerManager.exe") 
     
    $path = "C:\windows\system32\shell32.dll"
    $index = 238
    $icon = [System.IconExtractor]::Extract($path, $index, $true)
    
    # Add the systray icon 
    $Main_Tool_Icon = New-Object System.Windows.Forms.NotifyIcon
    $Main_Tool_Icon.Text = "SecureBoot Update Requires Reboot"
    $Main_Tool_Icon.Icon = $icon
    $Main_Tool_Icon.Visible = $true
    
    # Add menu exit
    $Menu_Exit = New-Object System.Windows.Forms.MenuItem
    $Menu_Exit.Text = "Exit"
    
    # Add all menus as context menus
    $contextmenu = New-Object System.Windows.Forms.ContextMenu
    $Main_Tool_Icon.ContextMenu = $contextmenu
    $Main_Tool_Icon.contextMenu.MenuItems.AddRange($Menu_Exit)
    
    [System.GC]::Collect()
}

